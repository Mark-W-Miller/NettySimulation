var Y=Object.defineProperty;var g=(o,e,t)=>e in o?Y(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var p=(o,e,t)=>g(o,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const n of r)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const n={};return r.integrity&&(n.integrity=r.integrity),r.referrerPolicy&&(n.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?n.credentials="include":r.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(r){if(r.ep)return;r.ep=!0;const n=t(r);fetch(r.href,n)}})();class I{constructor(){p(this,"canvas",null);p(this,"gl",null);p(this,"program",null);p(this,"sphere",null);p(this,"axes",null);p(this,"modelMatrix",L());p(this,"viewMatrix",L());p(this,"projectionMatrix",L());p(this,"normalMatrix",O());p(this,"camera",{azimuth:Math.PI/5,elevation:Math.PI/7,distance:4,panX:0,panY:0});p(this,"dragMode",null);p(this,"activePointerId",null);p(this,"dragStart",{x:0,y:0,azimuth:0,elevation:0,panX:0,panY:0});p(this,"resizeObserver",null);p(this,"cleanupCallbacks",[]);p(this,"animationHandle",0)}mount(e){this.dispose();const t=document.createElement("div");t.className="scene-container";const i=document.createElement("canvas");t.appendChild(i),e.innerHTML="",e.appendChild(t);const r=i.getContext("webgl");if(!r)throw new Error("WebGL not supported in this browser.");const n=this.createProgram(r),a=this.createSphere(r),s=this.createAxes(r);this.canvas=i,this.gl=r,this.program=n,this.sphere=a,this.axes=s,this.resize(i,r),this.resizeObserver=new ResizeObserver(()=>{this.canvas&&this.gl&&this.resize(this.canvas,this.gl)}),this.resizeObserver.observe(t),this.cleanupCallbacks.push(this.attachControls(t));const f=()=>{this.animationHandle=requestAnimationFrame(f),this.render()};f()}dispose(){var e;this.animationHandle&&(cancelAnimationFrame(this.animationHandle),this.animationHandle=0),this.cleanupCallbacks.forEach(t=>t()),this.cleanupCallbacks=[],(e=this.resizeObserver)==null||e.disconnect(),this.resizeObserver=null,this.gl&&this.sphere&&(this.gl.deleteBuffer(this.sphere.positionBuffer),this.gl.deleteBuffer(this.sphere.normalBuffer),this.gl.deleteBuffer(this.sphere.colorBuffer),this.gl.deleteBuffer(this.sphere.indexBuffer)),this.gl&&this.axes&&(this.gl.deleteBuffer(this.axes.positionBuffer),this.gl.deleteBuffer(this.axes.normalBuffer),this.gl.deleteBuffer(this.axes.colorBuffer)),this.gl&&this.program&&this.gl.deleteProgram(this.program.program),this.canvas=null,this.gl=null,this.program=null,this.sphere=null,this.axes=null}resize(e,t){const i=window.devicePixelRatio||1,r=Math.max(1,Math.floor(e.clientWidth*i)),n=Math.max(1,Math.floor(e.clientHeight*i));(e.width!==r||e.height!==n)&&(e.width=r,e.height=n),t.viewport(0,0,r,n),this.projectionMatrix=X(50*Math.PI/180,r/n,.1,100)}render(){if(!this.gl||!this.program||!this.sphere||!this.axes||!this.canvas)return;const e=this.gl,t=this.program;e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),e.clearColor(.03,.05,.09,1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const i=[this.camera.panX,this.camera.panY,0],r=N(this.camera.distance,this.camera.azimuth,this.camera.elevation,i),n=1.02,s=Math.hypot(r[0],r[1],r[2])>n+.05;this.viewMatrix=V(r,i,[0,1,0]),this.normalMatrix=W(this.modelMatrix),e.useProgram(t.program),e.uniformMatrix4fv(t.uniformModel,!1,this.modelMatrix),e.uniformMatrix4fv(t.uniformView,!1,this.viewMatrix),e.uniformMatrix4fv(t.uniformProjection,!1,this.projectionMatrix),e.uniformMatrix3fv(t.uniformNormalMatrix,!1,this.normalMatrix),e.uniform3fv(t.uniformLightDirection,D([.5,.8,.4])),e.bindBuffer(e.ARRAY_BUFFER,this.sphere.positionBuffer),e.vertexAttribPointer(t.attribPosition,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribPosition),e.bindBuffer(e.ARRAY_BUFFER,this.sphere.normalBuffer),e.vertexAttribPointer(t.attribNormal,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribNormal),e.bindBuffer(e.ARRAY_BUFFER,this.sphere.colorBuffer),e.vertexAttribPointer(t.attribColor,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribColor),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.sphere.indexBuffer),e.uniform1f(t.uniformUseVertexColor,0),e.uniform3fv(t.uniformColor,[.28,.46,.9]),e.uniform1f(t.uniformClipEnabled,0),e.disable(e.CULL_FACE),e.drawElements(e.TRIANGLES,this.sphere.indexCount,e.UNSIGNED_SHORT,0),e.enable(e.CULL_FACE),e.bindBuffer(e.ARRAY_BUFFER,this.axes.positionBuffer),e.vertexAttribPointer(t.attribPosition,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribPosition),e.bindBuffer(e.ARRAY_BUFFER,this.axes.normalBuffer),e.vertexAttribPointer(t.attribNormal,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribNormal),e.bindBuffer(e.ARRAY_BUFFER,this.axes.colorBuffer),e.vertexAttribPointer(t.attribColor,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribColor),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.axes.indexBuffer),e.disable(e.CULL_FACE),e.enable(e.POLYGON_OFFSET_FILL),e.polygonOffset(1,1),e.uniform1f(t.uniformUseVertexColor,1),e.uniform1f(t.uniformClipEnabled,s?1:0),e.uniform3f(t.uniformClipCenter,0,0,0),e.uniform1f(t.uniformClipRadius,n),e.drawElements(e.TRIANGLES,this.axes.indexCount,e.UNSIGNED_SHORT,0),e.disable(e.POLYGON_OFFSET_FILL),e.enable(e.CULL_FACE)}attachControls(e){const t=s=>{var c;let f=null;s.button===0&&s.altKey?f="pan":s.button===0?f="orbit":(s.button===1||s.button===2)&&(f="pan"),f&&(this.dragMode=f,this.activePointerId=s.pointerId,(c=e.setPointerCapture)==null||c.call(e,s.pointerId),this.dragStart={x:s.clientX,y:s.clientY,azimuth:this.camera.azimuth,elevation:this.camera.elevation,panX:this.camera.panX,panY:this.camera.panY},e.classList.toggle("is-orbiting",f==="orbit"),e.classList.toggle("is-panning",f==="pan"))},i=s=>{if(!this.dragMode||s.pointerId!==this.activePointerId)return;const f=s.clientX-this.dragStart.x,c=s.clientY-this.dragStart.y;if(this.dragMode==="orbit"){this.camera.azimuth=this.dragStart.azimuth-f*.005;const l=this.dragStart.elevation+c*.004,d=Math.PI/2-.05;this.camera.elevation=P(l,-d,d)}else if(this.dragMode==="pan"){if(!this.canvas)return;const h=.0025,m=H(this.dragStart.azimuth),l=G([f*h,-c*h,0],m);this.camera.panX=this.dragStart.panX+l[0],this.camera.panY=this.dragStart.panY+l[1]}},r=s=>{var f;s.pointerId===this.activePointerId&&((f=e.releasePointerCapture)==null||f.call(e,s.pointerId),this.activePointerId=null,this.dragMode=null,e.classList.remove("is-orbiting","is-panning"))},n=s=>{s.preventDefault();const c=this.camera.distance-s.deltaY*.0018;this.camera.distance=P(c,.15,12)},a=s=>{s.preventDefault()};return e.addEventListener("pointerdown",t),e.addEventListener("pointermove",i),e.addEventListener("pointerup",r),e.addEventListener("pointercancel",r),e.addEventListener("lostpointercapture",r),e.addEventListener("wheel",n,{passive:!1}),e.addEventListener("contextmenu",a),()=>{e.removeEventListener("pointerdown",t),e.removeEventListener("pointermove",i),e.removeEventListener("pointerup",r),e.removeEventListener("pointercancel",r),e.removeEventListener("lostpointercapture",r),e.removeEventListener("wheel",n),e.removeEventListener("contextmenu",a)}}createProgram(e){const t=`
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      attribute vec3 aColor;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat3 uNormalMatrix;
      uniform float uUseVertexColor;
      uniform vec3 uColor;

      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      varying vec3 vColor;

      void main() {
        vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
        vWorldPosition = worldPosition.xyz;
        vNormal = normalize(uNormalMatrix * aNormal);
        vColor = mix(uColor, aColor, uUseVertexColor);
        gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
      }
    `,i=`
      precision mediump float;

      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      varying vec3 vColor;

      uniform vec3 uLightDirection;
      uniform float uClipEnabled;
      uniform vec3 uClipCenter;
      uniform float uClipRadius;

      void main() {
        vec3 normal = normalize(vNormal);
        float diffuse = max(dot(normal, normalize(uLightDirection)), 0.0);
        float ambient = 0.25;
        if (uClipEnabled > 0.5) {
          float distanceToCenter = distance(vWorldPosition, uClipCenter);
          if (distanceToCenter < uClipRadius) {
            discard;
          }
        }
        vec3 shaded = vColor * (ambient + (1.0 - ambient) * diffuse);
        gl_FragColor = vec4(shaded, 1.0);
      }
    `,r=B(e,e.VERTEX_SHADER,t),n=B(e,e.FRAGMENT_SHADER,i),a=e.createProgram();if(!a)throw new Error("Failed to create WebGL program.");if(e.attachShader(a,r),e.attachShader(a,n),e.linkProgram(a),!e.getProgramParameter(a,e.LINK_STATUS)){const C=e.getProgramInfoLog(a);throw e.deleteProgram(a),e.deleteShader(r),e.deleteShader(n),new Error(`Failed to link WebGL program: ${C??"unknown error"}`)}e.deleteShader(r),e.deleteShader(n);const s=e.getAttribLocation(a,"aPosition"),f=e.getAttribLocation(a,"aNormal"),c=e.getAttribLocation(a,"aColor"),h=E(e,a,"uModelMatrix"),m=E(e,a,"uViewMatrix"),l=E(e,a,"uProjectionMatrix"),d=E(e,a,"uNormalMatrix"),A=E(e,a,"uLightDirection"),b=E(e,a,"uColor"),R=E(e,a,"uUseVertexColor"),v=E(e,a,"uClipEnabled"),x=E(e,a,"uClipCenter"),u=E(e,a,"uClipRadius");return{program:a,attribPosition:s,attribNormal:f,attribColor:c,uniformModel:h,uniformView:m,uniformProjection:l,uniformNormalMatrix:d,uniformLightDirection:A,uniformColor:b,uniformUseVertexColor:R,uniformClipEnabled:v,uniformClipCenter:x,uniformClipRadius:u}}createSphere(e){const{positions:t,normals:i,colors:r,indices:n}=z(48,48),a=e.createBuffer(),s=e.createBuffer(),f=e.createBuffer(),c=e.createBuffer();if(!a||!s||!f||!c)throw new Error("Failed to create sphere buffers.");return e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,f),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,c),e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW),{positionBuffer:a,normalBuffer:s,colorBuffer:f,indexBuffer:c,indexCount:n.length}}createAxes(e){const r=[],n=[],a=[],s=[],f=(d,A,b)=>{const[R,v]=A,x=.18/2,u={minX:d==="x"?R:-x,maxX:d==="x"?v:x,minY:d==="y"?R:-x,maxY:d==="y"?v:x,minZ:d==="z"?R:-x,maxZ:d==="z"?v:x},C=[[u.minX,u.minY,u.minZ],[u.maxX,u.minY,u.minZ],[u.maxX,u.maxY,u.minZ],[u.minX,u.maxY,u.minZ],[u.minX,u.minY,u.maxZ],[u.maxX,u.minY,u.maxZ],[u.maxX,u.maxY,u.maxZ],[u.minX,u.maxY,u.maxZ]],M=[{indices:[0,1,2,3],normal:[0,0,-1]},{indices:[5,4,7,6],normal:[0,0,1]},{indices:[4,0,3,7],normal:[-1,0,0]},{indices:[1,5,6,2],normal:[1,0,0]},{indices:[3,2,6,7],normal:[0,1,0]},{indices:[4,5,1,0],normal:[0,-1,0]}];for(const y of M){const F=r.length/3;for(const w of y.indices){const[_,T,U]=C[w];r.push(_,T,U),n.push(...y.normal),a.push(...b)}s.push(F,F+1,F+2,F,F+2,F+3)}};f("x",[0,3.6],[.2,.9,.5]),f("x",[-3.6,0],[.12,.6,.32]),f("y",[0,3.6],[.96,.94,.4]),f("y",[-3.6,0],[.68,.66,.18]),f("z",[0,3.6],[.38,.62,1]),f("z",[-3.6,0],[.24,.4,.76]);const c=e.createBuffer(),h=e.createBuffer(),m=e.createBuffer(),l=e.createBuffer();if(!c||!h||!m||!l)throw new Error("Failed to create axis buffers.");return e.bindBuffer(e.ARRAY_BUFFER,c),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,h),e.bufferData(e.ARRAY_BUFFER,new Float32Array(n),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,m),e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,l),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(s),e.STATIC_DRAW),{positionBuffer:c,normalBuffer:h,colorBuffer:m,indexBuffer:l,indexCount:s.length}}}function B(o,e,t){const i=o.createShader(e);if(!i)throw new Error("Failed to create WebGL shader.");if(o.shaderSource(i,t),o.compileShader(i),!o.getShaderParameter(i,o.COMPILE_STATUS)){const r=o.getShaderInfoLog(i);throw o.deleteShader(i),new Error(`Shader compile failure: ${r??"unknown error"}`)}return i}function E(o,e,t){const i=o.getUniformLocation(e,t);if(!i)throw new Error(`Uniform ${t} is missing.`);return i}function z(o,e){const t=[],i=[],r=[],n=[],a=[.62,.82,1],s=[.1,.24,.55];for(let c=0;c<=o;c+=1){const h=c*Math.PI/o,m=Math.sin(h),l=Math.cos(h);for(let d=0;d<=e;d+=1){const A=d*2*Math.PI/e,b=Math.sin(A),v=Math.cos(A)*m,x=l,u=b*m,M=(c+d)%2===0?a:s;t.push(v,x,u),i.push(v,x,u),r.push(...M)}}const f=e+1;for(let c=0;c<o;c+=1)for(let h=0;h<e;h+=1){const m=c*f+h,l=m+f;n.push(m,l,m+1),n.push(l,l+1,m+1)}return{positions:new Float32Array(t),normals:new Float32Array(i),colors:new Float32Array(r),indices:new Uint16Array(n)}}function N(o,e,t,i){const r=o*Math.cos(t)*Math.sin(e)+i[0],n=o*Math.sin(t)+i[1],a=o*Math.cos(t)*Math.cos(e)+i[2];return[r,n,a]}function D(o){const[e,t,i]=o,r=Math.hypot(e,t,i)||1;return new Float32Array([e/r,t/r,i/r])}function P(o,e,t){return Math.min(t,Math.max(e,o))}function L(){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function O(){return new Float32Array([1,0,0,0,1,0,0,0,1])}function X(o,e,t,i){const r=1/Math.tan(o/2),n=1/(t-i);return new Float32Array([r/e,0,0,0,0,r,0,0,0,0,(i+t)*n,-1,0,0,2*i*t*n,0])}function V(o,e,t){const[i,r,n]=o,[a,s,f]=e;let c=i-a,h=r-s,m=n-f,l=Math.hypot(c,h,m);l===0&&(c=0,h=0,m=1,l=1),c/=l,h/=l,m/=l;let d=t[1]*m-t[2]*h,A=t[2]*c-t[0]*m,b=t[0]*h-t[1]*c;l=Math.hypot(d,A,b),l===0?(d=0,A=0,b=0):(d/=l,A/=l,b/=l);let R=h*b-m*A,v=m*d-c*b,x=c*A-h*d;return l=Math.hypot(R,v,x),l>0&&(R/=l,v/=l,x/=l),new Float32Array([d,R,c,0,A,v,h,0,b,x,m,0,-(d*i+A*r+b*n),-(R*i+v*r+x*n),-(c*i+h*r+m*n),1])}function W(o){return new Float32Array([o[0],o[1],o[2],o[4],o[5],o[6],o[8],o[9],o[10]])}function H(o){const e=Math.cos(o),t=Math.sin(o);return new Float32Array([e,0,-t,0,0,1,0,0,t,0,e,0,0,0,0,1])}function G(o,e){const[t,i,r]=o;return[e[0]*t+e[4]*i+e[8]*r+e[12],e[1]*t+e[5]*i+e[9]*r+e[13],e[2]*t+e[6]*i+e[10]*r+e[14]]}const S=document.getElementById("app");if(!S)throw new Error("Root element #app not found in document.");const Z=new I;Z.mount(S);console.log("NettySimulation ready");
