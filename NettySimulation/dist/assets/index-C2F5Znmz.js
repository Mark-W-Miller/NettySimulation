var g=Object.defineProperty;var U=(n,e,t)=>e in n?g(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var p=(n,e,t)=>U(n,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&i(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(r){if(r.ep)return;r.ep=!0;const o=t(r);fetch(r.href,o)}})();class I{constructor(){p(this,"canvas",null);p(this,"gl",null);p(this,"program",null);p(this,"sphere",null);p(this,"axes",null);p(this,"modelMatrix",B());p(this,"viewMatrix",B());p(this,"projectionMatrix",B());p(this,"normalMatrix",O());p(this,"camera",{azimuth:Math.PI/5,elevation:Math.PI/7,distance:4,panX:0,panY:0});p(this,"dragMode",null);p(this,"activePointerId",null);p(this,"dragStart",{x:0,y:0,azimuth:0,elevation:0,panX:0,panY:0});p(this,"resizeObserver",null);p(this,"cleanupCallbacks",[]);p(this,"animationHandle",0)}mount(e){this.dispose();const t=document.createElement("div");t.className="scene-container";const i=document.createElement("canvas");t.appendChild(i),e.innerHTML="",e.appendChild(t);const r=i.getContext("webgl");if(!r)throw new Error("WebGL not supported in this browser.");const o=this.createProgram(r),a=this.createSphere(r),s=this.createAxes(r);this.canvas=i,this.gl=r,this.program=o,this.sphere=a,this.axes=s,this.resize(i,r),this.resizeObserver=new ResizeObserver(()=>{this.canvas&&this.gl&&this.resize(this.canvas,this.gl)}),this.resizeObserver.observe(t),this.cleanupCallbacks.push(this.attachControls(t));const f=()=>{this.animationHandle=requestAnimationFrame(f),this.render()};f()}dispose(){var e;this.animationHandle&&(cancelAnimationFrame(this.animationHandle),this.animationHandle=0),this.cleanupCallbacks.forEach(t=>t()),this.cleanupCallbacks=[],(e=this.resizeObserver)==null||e.disconnect(),this.resizeObserver=null,this.gl&&this.sphere&&(this.gl.deleteBuffer(this.sphere.positionBuffer),this.gl.deleteBuffer(this.sphere.normalBuffer),this.gl.deleteBuffer(this.sphere.colorBuffer),this.gl.deleteBuffer(this.sphere.indexBuffer)),this.gl&&this.axes&&(this.gl.deleteBuffer(this.axes.positionBuffer),this.gl.deleteBuffer(this.axes.normalBuffer),this.gl.deleteBuffer(this.axes.colorBuffer)),this.gl&&this.program&&this.gl.deleteProgram(this.program.program),this.canvas=null,this.gl=null,this.program=null,this.sphere=null,this.axes=null}resize(e,t){const i=window.devicePixelRatio||1,r=Math.max(1,Math.floor(e.clientWidth*i)),o=Math.max(1,Math.floor(e.clientHeight*i));(e.width!==r||e.height!==o)&&(e.width=r,e.height=o),t.viewport(0,0,r,o),this.projectionMatrix=X(50*Math.PI/180,r/o,.1,100)}render(){if(!this.gl||!this.program||!this.sphere||!this.axes||!this.canvas)return;const e=this.gl,t=this.program;e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),e.clearColor(.03,.05,.09,1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const i=[this.camera.panX,this.camera.panY,0],r=N(this.camera.distance,this.camera.azimuth,this.camera.elevation,i);this.viewMatrix=V(r,i,[0,1,0]),this.normalMatrix=W(this.modelMatrix),e.useProgram(t.program),e.uniformMatrix4fv(t.uniformModel,!1,this.modelMatrix),e.uniformMatrix4fv(t.uniformView,!1,this.viewMatrix),e.uniformMatrix4fv(t.uniformProjection,!1,this.projectionMatrix),e.uniformMatrix3fv(t.uniformNormalMatrix,!1,this.normalMatrix),e.uniform3fv(t.uniformLightDirection,D([.5,.8,.4])),e.bindBuffer(e.ARRAY_BUFFER,this.sphere.positionBuffer),e.vertexAttribPointer(t.attribPosition,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribPosition),e.bindBuffer(e.ARRAY_BUFFER,this.sphere.normalBuffer),e.vertexAttribPointer(t.attribNormal,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribNormal),e.bindBuffer(e.ARRAY_BUFFER,this.sphere.colorBuffer),e.vertexAttribPointer(t.attribColor,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribColor),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.sphere.indexBuffer),e.uniform1f(t.uniformUseVertexColor,1),e.uniform3fv(t.uniformColor,[.28,.46,.9]),e.drawElements(e.TRIANGLES,this.sphere.indexCount,e.UNSIGNED_SHORT,0),e.bindBuffer(e.ARRAY_BUFFER,this.axes.positionBuffer),e.vertexAttribPointer(t.attribPosition,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribPosition),e.bindBuffer(e.ARRAY_BUFFER,this.axes.normalBuffer),e.vertexAttribPointer(t.attribNormal,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribNormal),e.bindBuffer(e.ARRAY_BUFFER,this.axes.colorBuffer),e.vertexAttribPointer(t.attribColor,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.attribColor),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.axes.indexBuffer),e.disable(e.CULL_FACE),e.enable(e.POLYGON_OFFSET_FILL),e.polygonOffset(1,1),e.uniform1f(t.uniformUseVertexColor,1),e.drawElements(e.TRIANGLES,this.axes.indexCount,e.UNSIGNED_SHORT,0),e.disable(e.POLYGON_OFFSET_FILL),e.enable(e.CULL_FACE)}attachControls(e){const t=s=>{var c;let f=null;s.button===0&&s.altKey?f="pan":s.button===0?f="orbit":(s.button===1||s.button===2)&&(f="pan"),f&&(this.dragMode=f,this.activePointerId=s.pointerId,(c=e.setPointerCapture)==null||c.call(e,s.pointerId),this.dragStart={x:s.clientX,y:s.clientY,azimuth:this.camera.azimuth,elevation:this.camera.elevation,panX:this.camera.panX,panY:this.camera.panY},e.classList.toggle("is-orbiting",f==="orbit"),e.classList.toggle("is-panning",f==="pan"))},i=s=>{if(!this.dragMode||s.pointerId!==this.activePointerId)return;const f=s.clientX-this.dragStart.x,c=s.clientY-this.dragStart.y;if(this.dragMode==="orbit"){this.camera.azimuth=this.dragStart.azimuth+f*.005;const l=this.dragStart.elevation+c*.004,d=Math.PI/2-.05;this.camera.elevation=S(l,-d,d)}else if(this.dragMode==="pan"){const u=.003*this.camera.distance;this.camera.panX=this.dragStart.panX-f*u,this.camera.panY=this.dragStart.panY+c*u}},r=s=>{var f;s.pointerId===this.activePointerId&&((f=e.releasePointerCapture)==null||f.call(e,s.pointerId),this.activePointerId=null,this.dragMode=null,e.classList.remove("is-orbiting","is-panning"))},o=s=>{s.preventDefault();const c=this.camera.distance-s.deltaY*.0018;this.camera.distance=S(c,1.2,12)},a=s=>{s.preventDefault()};return e.addEventListener("pointerdown",t),e.addEventListener("pointermove",i),e.addEventListener("pointerup",r),e.addEventListener("pointercancel",r),e.addEventListener("lostpointercapture",r),e.addEventListener("wheel",o,{passive:!1}),e.addEventListener("contextmenu",a),()=>{e.removeEventListener("pointerdown",t),e.removeEventListener("pointermove",i),e.removeEventListener("pointerup",r),e.removeEventListener("pointercancel",r),e.removeEventListener("lostpointercapture",r),e.removeEventListener("wheel",o),e.removeEventListener("contextmenu",a)}}createProgram(e){const t=`
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      attribute vec3 aColor;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat3 uNormalMatrix;
      uniform float uUseVertexColor;
      uniform vec3 uColor;

      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      varying vec3 vColor;

      void main() {
        vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
        vWorldPosition = worldPosition.xyz;
        vNormal = normalize(uNormalMatrix * aNormal);
        vColor = mix(uColor, aColor, uUseVertexColor);
        gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
      }
    `,i=`
      precision mediump float;

      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      varying vec3 vColor;

      uniform vec3 uLightDirection;

      void main() {
        vec3 normal = normalize(vNormal);
        float diffuse = max(dot(normal, normalize(uLightDirection)), 0.0);
        float ambient = 0.25;
        vec3 shaded = vColor * (ambient + (1.0 - ambient) * diffuse);
        gl_FragColor = vec4(shaded, 1.0);
      }
    `,r=P(e,e.VERTEX_SHADER,t),o=P(e,e.FRAGMENT_SHADER,i),a=e.createProgram();if(!a)throw new Error("Failed to create WebGL program.");if(e.attachShader(a,r),e.attachShader(a,o),e.linkProgram(a),!e.getProgramParameter(a,e.LINK_STATUS)){const v=e.getProgramInfoLog(a);throw e.deleteProgram(a),e.deleteShader(r),e.deleteShader(o),new Error(`Failed to link WebGL program: ${v??"unknown error"}`)}e.deleteShader(r),e.deleteShader(o);const s=e.getAttribLocation(a,"aPosition"),f=e.getAttribLocation(a,"aNormal"),c=e.getAttribLocation(a,"aColor"),u=E(e,a,"uModelMatrix"),m=E(e,a,"uViewMatrix"),l=E(e,a,"uProjectionMatrix"),d=E(e,a,"uNormalMatrix"),x=E(e,a,"uLightDirection"),b=E(e,a,"uColor"),R=E(e,a,"uUseVertexColor");return{program:a,attribPosition:s,attribNormal:f,attribColor:c,uniformModel:u,uniformView:m,uniformProjection:l,uniformNormalMatrix:d,uniformLightDirection:x,uniformColor:b,uniformUseVertexColor:R}}createSphere(e){const{positions:t,normals:i,colors:r,indices:o}=z(48,48),a=e.createBuffer(),s=e.createBuffer(),f=e.createBuffer(),c=e.createBuffer();if(!a||!s||!f||!c)throw new Error("Failed to create sphere buffers.");return e.bindBuffer(e.ARRAY_BUFFER,a),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,f),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,c),e.bufferData(e.ELEMENT_ARRAY_BUFFER,o,e.STATIC_DRAW),{positionBuffer:a,normalBuffer:s,colorBuffer:f,indexBuffer:c,indexCount:o.length}}createAxes(e){const r=[],o=[],a=[],s=[],f=(d,x,b)=>{const[R,v]=x,A=.18/2,h={minX:d==="x"?R:-A,maxX:d==="x"?v:A,minY:d==="y"?R:-A,maxY:d==="y"?v:A,minZ:d==="z"?R:-A,maxZ:d==="z"?v:A},L=[[h.minX,h.minY,h.minZ],[h.maxX,h.minY,h.minZ],[h.maxX,h.maxY,h.minZ],[h.minX,h.maxY,h.minZ],[h.minX,h.minY,h.maxZ],[h.maxX,h.minY,h.maxZ],[h.maxX,h.maxY,h.maxZ],[h.minX,h.maxY,h.maxZ]],M=[{indices:[0,1,2,3],normal:[0,0,-1]},{indices:[5,4,7,6],normal:[0,0,1]},{indices:[4,0,3,7],normal:[-1,0,0]},{indices:[1,5,6,2],normal:[1,0,0]},{indices:[3,2,6,7],normal:[0,1,0]},{indices:[4,5,1,0],normal:[0,-1,0]}];for(const y of M){const F=r.length/3;for(const C of y.indices){const[_,T,Y]=L[C];r.push(_,T,Y),o.push(...y.normal),a.push(...b)}s.push(F,F+1,F+2,F,F+2,F+3)}};f("x",[0,3.6],[.2,.9,.5]),f("x",[-3.6,0],[.12,.6,.32]),f("y",[0,3.6],[.96,.94,.4]),f("y",[-3.6,0],[.68,.66,.18]),f("z",[0,3.6],[.38,.62,1]),f("z",[-3.6,0],[.24,.4,.76]);const c=e.createBuffer(),u=e.createBuffer(),m=e.createBuffer(),l=e.createBuffer();if(!c||!u||!m||!l)throw new Error("Failed to create axis buffers.");return e.bindBuffer(e.ARRAY_BUFFER,c),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,u),e.bufferData(e.ARRAY_BUFFER,new Float32Array(o),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,m),e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,l),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(s),e.STATIC_DRAW),{positionBuffer:c,normalBuffer:u,colorBuffer:m,indexBuffer:l,indexCount:s.length}}}function P(n,e,t){const i=n.createShader(e);if(!i)throw new Error("Failed to create WebGL shader.");if(n.shaderSource(i,t),n.compileShader(i),!n.getShaderParameter(i,n.COMPILE_STATUS)){const r=n.getShaderInfoLog(i);throw n.deleteShader(i),new Error(`Shader compile failure: ${r??"unknown error"}`)}return i}function E(n,e,t){const i=n.getUniformLocation(e,t);if(!i)throw new Error(`Uniform ${t} is missing.`);return i}function z(n,e){const t=[],i=[],r=[],o=[],a=[.62,.82,1],s=[.1,.24,.55];for(let c=0;c<=n;c+=1){const u=c*Math.PI/n,m=Math.sin(u),l=Math.cos(u);for(let d=0;d<=e;d+=1){const x=d*2*Math.PI/e,b=Math.sin(x),v=Math.cos(x)*m,A=l,h=b*m,M=(c+d)%2===0?a:s;t.push(v,A,h),i.push(v,A,h),r.push(...M)}}const f=e+1;for(let c=0;c<n;c+=1)for(let u=0;u<e;u+=1){const m=c*f+u,l=m+f;o.push(m,l,m+1),o.push(l,l+1,m+1)}return{positions:new Float32Array(t),normals:new Float32Array(i),colors:new Float32Array(r),indices:new Uint16Array(o)}}function N(n,e,t,i){const r=n*Math.cos(t)*Math.sin(e)+i[0],o=n*Math.sin(t)+i[1],a=n*Math.cos(t)*Math.cos(e)+i[2];return[r,o,a]}function D(n){const[e,t,i]=n,r=Math.hypot(e,t,i)||1;return new Float32Array([e/r,t/r,i/r])}function S(n,e,t){return Math.min(t,Math.max(e,n))}function B(){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function O(){return new Float32Array([1,0,0,0,1,0,0,0,1])}function X(n,e,t,i){const r=1/Math.tan(n/2),o=1/(t-i);return new Float32Array([r/e,0,0,0,0,r,0,0,0,0,(i+t)*o,-1,0,0,2*i*t*o,0])}function V(n,e,t){const[i,r,o]=n,[a,s,f]=e;let c=i-a,u=r-s,m=o-f,l=Math.hypot(c,u,m);l===0&&(c=0,u=0,m=1,l=1),c/=l,u/=l,m/=l;let d=t[1]*m-t[2]*u,x=t[2]*c-t[0]*m,b=t[0]*u-t[1]*c;l=Math.hypot(d,x,b),l===0?(d=0,x=0,b=0):(d/=l,x/=l,b/=l);let R=u*b-m*x,v=m*d-c*b,A=c*x-u*d;return l=Math.hypot(R,v,A),l>0&&(R/=l,v/=l,A/=l),new Float32Array([d,R,c,0,x,v,u,0,b,A,m,0,-(d*i+x*r+b*o),-(R*i+v*r+A*o),-(c*i+u*r+m*o),1])}function W(n){return new Float32Array([n[0],n[1],n[2],n[4],n[5],n[6],n[8],n[9],n[10]])}const w=document.getElementById("app");if(!w)throw new Error("Root element #app not found in document.");const H=new I;H.mount(w);console.log("NettySimulation ready");
